\section{Diagramme des classes pour le serveur.}

\begin{flushleft}
Étant donnée la taille du projet, nous avons évidemment décidé de séparer le projet en plusieurs parties. Au niveau du serveur, nous pouvons compter 3 grandes parties.
\end{flushleft}

\begin{enumerate}[-]
\item Le package api.
\item Le package database.
\item Le package dataObject.
\end{enumerate}

\begin{flushleft}
Il y a également la classe de base nommé App comme quatrième partie. Nous en reparlerons par après.
Notez également que nous avons définis une classe pour énumérer les différents type d'énergie.
\end{flushleft}

\subsection{Le package api:}

\begin{flushleft}
Ce package qui contient toute la partie logique de l'ApiRest. Pour créer une ApiRest, nous avons d'abord besoin d'une classe (MyApi) qui hérite de AbstractVerticle (une classe abstraite venant du package vertx). MyApi permet de lancer le serveur à l'aide de la méthode start. Avant de la lancer, il faut d'abord configurer les routes de notre api. Notre api étant conséquente, nous avons décidé de la séparer en 4 sous-routes (parties distinctes).
\end{flushleft}

\begin{enumerate}[a)]
\item \textbf{LogApi:}\newline
Celle-ci va être utilisé pour toutes les opérations liées au login. Autrement dit, pouvoir se connecter et se déconnecter, créer un compte et réinitialiser son mot de passe en cas d'oublie.
\item \textbf{ClientApi:}\newline
Celle-ci va être utilisé pour toutes les requêtes liées aux clients lorsqu'ils seront connectés. Ils pourront effectuer toutes les opérations qu'ils souhaitent au niveau du portefeuille ainsi que voir tout leurs contrats et pour finir voir toutes les propositions des fournisseurs ou une en particulier.
\item \textbf{ProviderApi:}\newline
Celle-ci va être utilisé pour toutes les requêtes liées aux fournisseurs lorsqu'ils seront connectés. Ils pourront effectuer toutes les opérations qu'ils souhaitent au niveau des leurs propositions mais également voir tout les clients de l'application, tout leurs clients ou un client en particulier.
\item \textbf{CommonApi:}\newline
Celle-ci va être utilisé pour toutes les requêtes qui sont communes aux clients et aux fournisseurs lorsqu'ils seront connectés. On y trouve les méthodes pour les langues, pour les notifications et pour les données de consommations. Il y a également une méthode pour voir un contrat en particulier ainsi qu'une méthode pour proposer un contrat.
\end{enumerate}

\newpage

\begin{flushleft}
Chacune de ces parties vont donc créer une sous-route grâce à la méthode getSubRouter car elles implémentes toutes l'interface Router. Et c'est donc dans la méthode start de MyApi que toutes ces sous-routes vont être rassembler.
\newline
Notez que toutes les méthodes qui vont être appelées par l'api sont en privées car seul le serveur api peut les appeler et elles ont  le même argument (routingContext) car c'est cette variable qui contient la requête de l'utilisateur ainsi que le corps de la requête. Et c'est également par cette variable que nous pourrons répondre à l'utilisateur.
\newline
Nous constatons également que ces quatre parties héritent d'une classe abstraite nommé AbstractToken. Comme son nom l'indique, elle va gérer les tokens. Autrement dit, lorsqu'un utilisateur se connecte, on va crée un token et c'est grâce à ce token qu'il pourra envoyer des requêtes aux classes clientApi, ProviderApi et CommonApi. Le token se supprimera automatiquement après un certains délai ou quand l'utilisateur se déconnectera.
\end{flushleft}

\subsection{Le package database.}

\begin{flushleft}
Le package database contient toutes les méthodes qui vont communiquer avec la base de données. Une grande partie de celle-ci ont exactement le même nom que dans le package api car c'est dans la suite du programme; L'utilisateur envoie une requête à l'api, en fonction de la requête, la bonne méthode est appelé et appellera la méthode de database portant le même nom pour accéder aux données. Pour séparer le programme, nous avons divisé  cette partie en trois. Nous retrouvons donc une classe mère et deux classes filles.
\end{flushleft}

\begin{flushleft}
CommonDB est la classe mère de ce package, elle reprends toutes les méthodes communes aux clients et aux fournisseurs comme son nom l'indique. Outre les méthodes de l'api, nous retrouvons également les méthodes createNotification, deleteNotification et createContract car elles devront être appeler à la suite d'une requête et non directement. Nous avons aussi décider d'ajouter les méthodes createId, getDataOfTable et deleteDataOfTable car ce sont des actions qui seront souvent utiliser et que nous pouvons donc généraliser.
\end{flushleft}

\begin{flushleft}
ClientDB et Provider sont les deux classes enfants, elles s'occupent respectivement du côté client et du côté fournisseurs comme leurs noms l'indiquent. Elles héritent de la classe CommonDB pour avoir accès à certaines méthodes comme par exemple createId, getDataOfTable et deleteDataOfTable. Notez qu'au niveau du client nous avons rajouter une méthode walletIsEmpty qui permet de savoir si un portefeuille du client est vide.
\end{flushleft}

\subsection{Le package dataObject.}

\begin{flushleft}
Le package dataObject contient toutes les classes représentants un objet, c'est-à-dire:
\end{flushleft}

\begin{enumerate}[-]
\item Les portefeuilles.
\item Les contrats.
\item Les clients (du point de vue des fournisseurs).
\item Les propositions (que les fournisseurs ont créées).
\item Les notifications.
\end{enumerate}

\begin{flushleft}
Nous avons décidé de créer ces objets pour transférer facilement les données. En effet toutes les classes ne contiennent que des attributs avec des assesseurs à quelques exceptions près. Notez que nous aurions donc pût mettre les variables en final mais nous avions préféré laisser comme ça car dans le cas contraire nous aurions eu des constructeurs vraiment longs. Ces classes seront donc instanciées lorsque nous recevrons un objet par l'api ou quand nous prendrons des données de la base de données pour facilement les envoyer à l'utilisateur en format json.
\end{flushleft}

\begin{flushleft}
À l'exception de la classe notification, nous avons choisit de séparer chaque sortes objet en deux parties, une partie basique avec les informations primaires et une partie full avec le reste des informations. Cela nous permet, lorsque l'utilisateur souhaite par exemple voir tous ces portefeuilles, d'envoyer seulement le nécessaire au lieu d'envoyer toute les données en une fois. Ce n'est que quand l'utilisateur cliquera sur un portefeuille en particulier que nous enverrons toutes les données de celui-ci.
\end{flushleft}

\subsection{La classe App.}

\begin{flushleft}
La classe App est le début du programme. C'est elle qui est chargée de lancer le programme comme tout application java grâce à la méthode nommée "main". En effet, cette méthode va lancer l'api de la classe Myapi. Notez que nous n'avons pas directement lié ces deux classes entre elles car l'api se lance indirectement par le framework Vertx.
\end{flushleft}

\begin{flushleft}
La classe App contient également quelques méthodes statiques utiliser par les autres parties du projet. Ce sont ces méthodes qui s'occupent de la partie mail du projet, notamment "sendEmail" qui enverra une mail à un utilisateur qui souhaite réinitialiser son mot de passe ou bien le changer. Les autres méthodes s'occupe du "code". En effet, nous avons décidé que lorsqu'un utilisateur souhaite réinitialiser son mot de passe ou bien juste le changer, nous allons lui envoyer un code par mail avec quelques explications. Nous avons donc besoin d'une méthode pour générer le code, une pour vérifier que l'utilisateur a entré le bon code et pour finir une pour supprimer le code si l'utilisateur a mis trop de temps pour l'envoyer.
\end{flushleft}